
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    /**
     * @description
     * Rules for the global application settings collection. During prototyping, this allows any
     * authenticated user to manage the single settings document. In production, this MUST be 
     * restricted to administrative roles.
     * @path
     * /settings/{settingId}
     */
    match /settings/{settingId} {
      // Allow read and write only on the specific 'global' settings document
      allow get, create, update: if isSignedIn() && settingId == 'global';
      
      // Explicitly deny list and delete for security
      allow list, delete: if false;
    }

    /**
     * @description
     * Rules for the invoices collection. Users can create invoices and can only read/update/delete
     * their own invoices. Users can list invoices only if they are querying for their own user ID.
     * @path
     * /invoices/{invoiceId}
     */
    match /invoices/{invoiceId} {
        allow create: if isSignedIn() && isOwner(request.resource.data.userId);
        allow read, update, delete: if isSignedIn() && isOwner(resource.data.userId);
        allow list: if isSignedIn() && request.query.where.userId == request.auth.uid;
    }

    /**
     * @description
     * Rules for the products collection. Allows any authenticated user to manage products.
     * For production, you might want to restrict write access to admin users.
     * @path
     * /products/{productId}
     */
    match /products/{productId} {
      allow read, list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.id == productId;
      allow update: if isSignedIn();
      allow delete: if false; // Prevent hard deletes
    }
  }
}
